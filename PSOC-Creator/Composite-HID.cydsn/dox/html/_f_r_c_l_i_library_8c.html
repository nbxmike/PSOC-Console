<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PSOC Joystick: Source/FRCLILibrary.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PSOC Joystick
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('_f_r_c_l_i_library_8c.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">FRCLILibrary.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Support library and port of CLI task to Cypress PSOC 5LP.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;project.h&quot;</code><br />
<code>#include &quot;FreeRTOS.h&quot;</code><br />
<code>#include &quot;<a class="el" href="_f_r_support_8h_source.html">FRSupport.h</a>&quot;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &quot;FreeRTOS_CLI.h&quot;</code><br />
<code>#include &quot;timers.h&quot;</code><br />
<code>#include &quot;semphr.h&quot;</code><br />
<code>#include &quot;<a class="el" href="_f_r_c_l_i_library_8h_source.html">FRCLILibrary.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_u_s_b_host_8h_source.html">USBHost.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="globals_8h_source.html">globals.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:adc2bcd4282e5f7d7ecc83417ad4535b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_f_r_c_l_i_library_8c.html#adc2bcd4282e5f7d7ecc83417ad4535b0">CH_Init</a> (void)</td></tr>
<tr class="memdesc:adc2bcd4282e5f7d7ecc83417ad4535b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">CH_Init starts the user's comm port.  <a href="#adc2bcd4282e5f7d7ecc83417ad4535b0">More...</a><br /></td></tr>
<tr class="separator:adc2bcd4282e5f7d7ecc83417ad4535b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f3094784cfcf26d741f00c1fa59fb6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_f_r_c_l_i_library_8c.html#a25f3094784cfcf26d741f00c1fa59fb6">CH_StartUp</a> (void)</td></tr>
<tr class="memdesc:a25f3094784cfcf26d741f00c1fa59fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">CH_StartUp cleans up the USB if it is configured/recofigured.  <a href="#a25f3094784cfcf26d741f00c1fa59fb6">More...</a><br /></td></tr>
<tr class="separator:a25f3094784cfcf26d741f00c1fa59fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e92fe33160f42b842178c512e2beee4"><td class="memItemLeft" align="right" valign="top">uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_f_r_c_l_i_library_8c.html#a6e92fe33160f42b842178c512e2beee4">CH_DeviceReady</a> (void)</td></tr>
<tr class="memdesc:a6e92fe33160f42b842178c512e2beee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">CH_DeviceReady checks for console input.  <a href="#a6e92fe33160f42b842178c512e2beee4">More...</a><br /></td></tr>
<tr class="separator:a6e92fe33160f42b842178c512e2beee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35ca51ddad1bb883b0a78deaf11ed87c"><td class="memItemLeft" align="right" valign="top">uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_f_r_c_l_i_library_8c.html#a35ca51ddad1bb883b0a78deaf11ed87c">CH_DataIsReady</a> (void)</td></tr>
<tr class="memdesc:a35ca51ddad1bb883b0a78deaf11ed87c"><td class="mdescLeft">&#160;</td><td class="mdescRight">CH_DataIsReady checks for console input.  <a href="#a35ca51ddad1bb883b0a78deaf11ed87c">More...</a><br /></td></tr>
<tr class="separator:a35ca51ddad1bb883b0a78deaf11ed87c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ad974b34fd6e4619050e2e3561b00b"><td class="memItemLeft" align="right" valign="top">uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_f_r_c_l_i_library_8c.html#a10ad974b34fd6e4619050e2e3561b00b">CH_GetChar</a> (void)</td></tr>
<tr class="memdesc:a10ad974b34fd6e4619050e2e3561b00b"><td class="mdescLeft">&#160;</td><td class="mdescRight">CH_GetChar returns the next user input byte.  <a href="#a10ad974b34fd6e4619050e2e3561b00b">More...</a><br /></td></tr>
<tr class="separator:a10ad974b34fd6e4619050e2e3561b00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb2abc5dca193cd408a7524ca303e2a5"><td class="memItemLeft" align="right" valign="top">uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_f_r_c_l_i_library_8c.html#acb2abc5dca193cd408a7524ca303e2a5">CH_GetCharWait</a> (void)</td></tr>
<tr class="memdesc:acb2abc5dca193cd408a7524ca303e2a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">CH_GetCharWait return the next user byte and will wait if it is not avialible.  <a href="#acb2abc5dca193cd408a7524ca303e2a5">More...</a><br /></td></tr>
<tr class="separator:acb2abc5dca193cd408a7524ca303e2a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae4647229860bf00d438b369bac79c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_f_r_c_l_i_library_8c.html#acae4647229860bf00d438b369bac79c3">CH_PutData</a> (const uint8 *pData, uint16 length)</td></tr>
<tr class="memdesc:acae4647229860bf00d438b369bac79c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">CH_PutData puts arbitrary data in the send buffer.  <a href="#acae4647229860bf00d438b369bac79c3">More...</a><br /></td></tr>
<tr class="separator:acae4647229860bf00d438b369bac79c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93a3d707cf3f0f26551aca2d1fcfd09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_f_r_c_l_i_library_8c.html#aa93a3d707cf3f0f26551aca2d1fcfd09">CH_PutString</a> (const char *string)</td></tr>
<tr class="memdesc:aa93a3d707cf3f0f26551aca2d1fcfd09"><td class="mdescLeft">&#160;</td><td class="mdescRight">CH_PutString puts a character string in the send buffer.  <a href="#aa93a3d707cf3f0f26551aca2d1fcfd09">More...</a><br /></td></tr>
<tr class="separator:aa93a3d707cf3f0f26551aca2d1fcfd09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1526bb6cce06bc264a9fcee14271bb7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_f_r_c_l_i_library_8c.html#a1526bb6cce06bc264a9fcee14271bb7a">CH_PutChar</a> (char txDataByte)</td></tr>
<tr class="memdesc:a1526bb6cce06bc264a9fcee14271bb7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">CH_PutChar puts a single character in the send buffer.  <a href="#a1526bb6cce06bc264a9fcee14271bb7a">More...</a><br /></td></tr>
<tr class="separator:a1526bb6cce06bc264a9fcee14271bb7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b091b72ebf6e0ebd9b79dd262bebc5"><td class="memItemLeft" align="right" valign="top">BaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_f_r_c_l_i_library_8c.html#ab3b091b72ebf6e0ebd9b79dd262bebc5">echoCommand</a> (char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString)</td></tr>
<tr class="memdesc:ab3b091b72ebf6e0ebd9b79dd262bebc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">echoCommand process an echo command at the CLI  <a href="#ab3b091b72ebf6e0ebd9b79dd262bebc5">More...</a><br /></td></tr>
<tr class="separator:ab3b091b72ebf6e0ebd9b79dd262bebc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2896866b64b511f1f0f4bb652a5b3e8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_f_r_c_l_i_library_8c.html#a2896866b64b511f1f0f4bb652a5b3e8d">USBCOMP_EP_3_ISR_ExitCallback</a> (void)</td></tr>
<tr class="memdesc:a2896866b64b511f1f0f4bb652a5b3e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">USBFS_EP_3_ISR_EntryCallback ISR hook to tell foeground data may be ready.  <a href="#a2896866b64b511f1f0f4bb652a5b3e8d">More...</a><br /></td></tr>
<tr class="separator:a2896866b64b511f1f0f4bb652a5b3e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e8138fdff57d98ef8802a40a59d98b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_f_r_c_l_i_library_8c.html#a2e8138fdff57d98ef8802a40a59d98b4">cliTask</a> (void *arg)</td></tr>
<tr class="memdesc:a2e8138fdff57d98ef8802a40a59d98b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">cliTask task which invokes the FreeRTOS CLI engine  <a href="#a2e8138fdff57d98ef8802a40a59d98b4">More...</a><br /></td></tr>
<tr class="separator:a2e8138fdff57d98ef8802a40a59d98b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Support library and port of CLI task to Cypress PSOC 5LP. </p>
<dl class="section author"><dt>Author</dt><dd>Mike McCormack (nbxmike) </dd></dl>
<dl class="section date"><dt>Date</dt><dd>8/OCT/2018 Support library for the FreeRTOS command line interpreter and port of their CLI task to Cypress PSOC 5LP. All the CH_xxx deal with the CLI Human interface device. This will typically be a real or virtual UART device; for the present build it is a USB virtual UART (CDC device). </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a35ca51ddad1bb883b0a78deaf11ed87c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35ca51ddad1bb883b0a78deaf11ed87c">&#9670;&nbsp;</a></span>CH_DataIsReady()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8 CH_DataIsReady </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CH_DataIsReady checks for console input. </p>
<p>CH_DataIsReady looks to see if there is user input in the device buffer. In this implementation, it also checks if the USB has be reset by the host and if so will run the init routine. </p>

</div>
</div>
<a id="a6e92fe33160f42b842178c512e2beee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e92fe33160f42b842178c512e2beee4">&#9670;&nbsp;</a></span>CH_DeviceReady()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8 CH_DeviceReady </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CH_DeviceReady checks for console input. </p>
<p>CH_DeviceReady returns zero unless the system has completed initialization of the CLI Human interface device. This does not configure the device, it merely checks status. It is needed to ensure that virtual UARTs are started on the host side of a USB CDC device, if a harware UART is used then this could be replaced with a macro which always returns 1 (unless there is some error checking or protocol handshake that needs to get done.) </p>

</div>
</div>
<a id="a10ad974b34fd6e4619050e2e3561b00b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10ad974b34fd6e4619050e2e3561b00b">&#9670;&nbsp;</a></span>CH_GetChar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8 CH_GetChar </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CH_GetChar returns the next user input byte. </p>
<p>CH_GetChar will return the next byte form the user input in the device buffer. This routine does not check if there is data to be obtained, it should only be called if the CH_DataIsReady function indicates there is data to be had. In this implementation, it also checks if the USB has been reset by the host and if so will run the init routine; in this case the CH_GetChar routine returns a newline to terminate any input that was in process when the USB was reset/restarted. </p>

</div>
</div>
<a id="acb2abc5dca193cd408a7524ca303e2a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb2abc5dca193cd408a7524ca303e2a5">&#9670;&nbsp;</a></span>CH_GetCharWait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8 CH_GetCharWait </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CH_GetCharWait return the next user byte and will wait if it is not avialible. </p>
<p>CH_GetCharWait will return the next byte form the user input in the device buffer. This routine checks if data is avialable and if not will wait; the wait is for 10mS or until data is sent by the host, which ever comes first. If 10ms has expired and there is still no data the fnction waits another 10ms. In this implementation, it also checks if the USB has been reset by the host and if so will run the init routine; in this case the CH_GetCharWait routine returns a newline to terminate any input that was in process when the USB was reset/restarted. </p>

</div>
</div>
<a id="adc2bcd4282e5f7d7ecc83417ad4535b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc2bcd4282e5f7d7ecc83417ad4535b0">&#9670;&nbsp;</a></span>CH_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CH_Init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CH_Init starts the user's comm port. </p>
<p>CH_Init will start the interface and clear and data that was present before it begins. Typically there will be nothing as this should start at power up, but just in case . . . </p>

</div>
</div>
<a id="a1526bb6cce06bc264a9fcee14271bb7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1526bb6cce06bc264a9fcee14271bb7a">&#9670;&nbsp;</a></span>CH_PutChar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CH_PutChar </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>txDataByte</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CH_PutChar puts a single character in the send buffer. </p>
<p>CH_PutChar will put a single character into the output buffer of the user interface device. Since this will copy any value, it is suitable for arbitrary byte which may include zeros or printable characters equally well. In this implementation, it also checks if the USB has been reset by the host and if so will run the USB init routine. </p>

</div>
</div>
<a id="acae4647229860bf00d438b369bac79c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acae4647229860bf00d438b369bac79c3">&#9670;&nbsp;</a></span>CH_PutData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CH_PutData </td>
          <td>(</td>
          <td class="paramtype">const uint8 *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CH_PutData puts arbitrary data in the send buffer. </p>
<p>CH_PutData will put any bytes in the output buffer of the user interface device. The number of bytes to send must be specified. For null terminated strings CH_PutString is a more friendly call. In this implementation, it also checks if the USB has been reset by the host and if so will run the USB init routine. </p>

</div>
</div>
<a id="aa93a3d707cf3f0f26551aca2d1fcfd09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa93a3d707cf3f0f26551aca2d1fcfd09">&#9670;&nbsp;</a></span>CH_PutString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CH_PutString </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CH_PutString puts a character string in the send buffer. </p>
<p>CH_PutString will put a null terminated string into the output buffer of the user interface device. For arbitrary byte which may include zeros, CH_PutData is the proper interface call. In this implementation, it also checks if the USB has been reset by the host and if so will run the USB init routine. </p>

</div>
</div>
<a id="a25f3094784cfcf26d741f00c1fa59fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25f3094784cfcf26d741f00c1fa59fb6">&#9670;&nbsp;</a></span>CH_StartUp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CH_StartUp </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CH_StartUp cleans up the USB if it is configured/recofigured. </p>
<p>CH_StartUp will see to it that data in the buffer is cleared if the USB changes configuration either intially or after the systems has started. </p>

</div>
</div>
<a id="a2e8138fdff57d98ef8802a40a59d98b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e8138fdff57d98ef8802a40a59d98b4">&#9670;&nbsp;</a></span>cliTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cliTask </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cliTask task which invokes the FreeRTOS CLI engine </p>
<p>cliTask process the user input on the command line. At present it only support character input and backspace editing; there is no support for cursor movement or anything else. To make things as platform independant as possible this accepts DEL or BS as backspace, accepts CR, LF, or CR-LF as input termination. </p>

</div>
</div>
<a id="ab3b091b72ebf6e0ebd9b79dd262bebc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3b091b72ebf6e0ebd9b79dd262bebc5">&#9670;&nbsp;</a></span>echoCommand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BaseType_t echoCommand </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pcWriteBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>xWriteBufferLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pcCommandString</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>echoCommand process an echo command at the CLI </p>
<p>echoCommand is called by the FreeRTOS CLI tool when the user input starts with echo. This is a demonstration command to provide a platform independant command that can always be present. Delete from your port of the FreeRTOS CLI if you need the space. </p>

</div>
</div>
<a id="a2896866b64b511f1f0f4bb652a5b3e8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2896866b64b511f1f0f4bb652a5b3e8d">&#9670;&nbsp;</a></span>USBCOMP_EP_3_ISR_ExitCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBCOMP_EP_3_ISR_ExitCallback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USBFS_EP_3_ISR_EntryCallback ISR hook to tell foeground data may be ready. </p>
<p>USBFS_EP_3_ISR_EntryCallback is called by the USB IRQ handler when there is a data transfer from the host. It is unclear if this is called when the data field is zero lenght or if the tranfer was found to be corrupt so the foreground must still check if data is available. This hook can change even for the PSOC parts if the USB endpoints for the virtual UART change. That means it may be necessary to port this when the configuration changes, not just when the processor does. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_74389ed8173ad57b461b9d623a1f3867.html">Source</a></li><li class="navelem"><a class="el" href="_f_r_c_l_i_library_8c.html">FRCLILibrary.c</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
